diff --git a/index.html b/index.html
index dd6906f6dd27c0d529f9560727a18f98f91a3524..d92a1b7c9452cdb32e43e2f718d3f39822ac7ffe 100644
--- a/index.html
+++ b/index.html
@@ -403,183 +403,401 @@
             { from: 'PEREYRA', to: 'PSB', label: 'Счет офшора' },
             { from: 'IFNS', to: 'SE2', label: 'Проверка / Истец (суд)' },
             { from: 'AS_VO', to: 'SE2', label: 'Суд по банкротству' },
             { from: 'MURAVIEV', to: 'AS_VO', label: 'Судья' },
             { from: 'AKIMOV', to: 'AS_VO', label: 'Судья' },
             { from: 'BONDARENKO', to: 'SE2', label: 'Юрист' },
             { from: 'MANZHUR', to: 'EM', label: 'Юрист' },
             { from: 'MATYUSHINA', to: 'EM', label: 'Юрист' },
             { from: 'SHPAK', to: 'BOGD', label: 'Юрист' },
             { from: 'KOMASIN', to: 'VOLMA', label: 'Юрист' },
             { from: 'ROMANYUK', to: 'IFNS', label: 'Юрист' },
             { from: 'SE2', to: 'INVESTSOCBANK', label: 'Транзакции (счет)' },
             { from: 'EM', to: 'INVESTSOCBANK', label: 'Счета компании' },
             { from: 'CH_L', to: 'INVESTSOCBANK', label: 'Личные счета' },
             { from: 'CH_A_P', to: 'INVESTSOCBANK', label: 'Личные счета' },
             { from: 'SE2', to: 'CH_L', label: 'Вывод (Газпромбанк)' },
             { from: 'CH_L', to: 'GAZPROMBANK', label: 'Личный счет' }
         ];
 
         // Объединяем базовые рёбра с OSINT-данными из sf_data.js
         const rawEdgesData = [
             ...baseEdgesData,
             ...(window.rawEdgesData || [])
         ];
 
+        function buildHierarchyMeta(nodesList, edgesList) {
+            const nodeIds = new Set(nodesList.map(n => n.id));
+            const bankruptRoot = nodesList.find(n => n.group === 'bankrupt');
+            const rootId = bankruptRoot ? bankruptRoot.id : nodesList[0]?.id;
+
+            const outgoing = new Map();
+            const incoming = new Map();
+            nodeIds.forEach(id => {
+                outgoing.set(id, []);
+                incoming.set(id, []);
+            });
+
+            edgesList.forEach((e, idx) => {
+                const edgeId = e.id ?? `e_${idx}`;
+                if (!nodeIds.has(e.from) || !nodeIds.has(e.to)) return;
+                outgoing.get(e.from).push({ to: e.to, edgeId });
+                incoming.get(e.to).push({ from: e.from, edgeId });
+            });
+
+            const cycleEdgeIds = new Set();
+            const visited = new Set();
+            const inStack = new Set();
+
+            function dfs(nodeId) {
+                visited.add(nodeId);
+                inStack.add(nodeId);
+                for (const edge of outgoing.get(nodeId) || []) {
+                    if (inStack.has(edge.to)) {
+                        cycleEdgeIds.add(edge.edgeId);
+                        continue;
+                    }
+                    if (!visited.has(edge.to)) dfs(edge.to);
+                }
+                inStack.delete(nodeId);
+            }
+
+            if (rootId) dfs(rootId);
+            nodeIds.forEach(id => { if (!visited.has(id)) dfs(id); });
+
+            const levelById = new Map();
+            if (rootId) {
+                const queue = [rootId];
+                levelById.set(rootId, 0);
+                while (queue.length) {
+                    const current = queue.shift();
+                    const currentLevel = levelById.get(current);
+                    for (const edge of outgoing.get(current) || []) {
+                        if (cycleEdgeIds.has(edge.edgeId)) continue;
+                        const nextLevel = currentLevel + 1;
+                        if (!levelById.has(edge.to) || nextLevel < levelById.get(edge.to)) {
+                            levelById.set(edge.to, nextLevel);
+                            queue.push(edge.to);
+                        }
+                    }
+                }
+            }
+
+            const fallbackLevel = (rootId ? 1 : 0) + Math.max(0, ...Array.from(levelById.values()));
+            nodeIds.forEach(id => {
+                if (!levelById.has(id)) levelById.set(id, fallbackLevel);
+            });
+
+            const childCount = new Map();
+            nodeIds.forEach(id => childCount.set(id, 0));
+            edgesList.forEach((e, idx) => {
+                const edgeId = e.id ?? `e_${idx}`;
+                if (cycleEdgeIds.has(edgeId) || !childCount.has(e.from)) return;
+                childCount.set(e.from, childCount.get(e.from) + 1);
+            });
+
+            const nodeWeight = new Map();
+            nodesList.forEach(n => {
+                const revenueScore = Number(n.revenue || n.amount || 0) || 0;
+                nodeWeight.set(n.id, revenueScore + childCount.get(n.id));
+            });
+
+            return { rootId, cycleEdgeIds, levelById, nodeWeight, outgoing, incoming };
+        }
+
+        const hierarchyMeta = buildHierarchyMeta(rawNodesData, rawEdgesData);
+        const sortedEdgesData = [...rawEdgesData].sort((a, b) => {
+            const aLevel = hierarchyMeta.levelById.get(a.from) ?? 999;
+            const bLevel = hierarchyMeta.levelById.get(b.from) ?? 999;
+            if (aLevel !== bLevel) return aLevel - bLevel;
+
+            const aWeight = hierarchyMeta.nodeWeight.get(a.to) || 0;
+            const bWeight = hierarchyMeta.nodeWeight.get(b.to) || 0;
+            return bWeight - aWeight;
+        });
+
         // АЛГОРИТМ РАСКРАСКИ РЕБЕР (Скрываем текст с линий)
-        const processedEdges = rawEdgesData.map((e, idx) => {
+        const processedEdges = sortedEdgesData.map((e, idx) => {
             let edgeColor = '#555';
             let width = 1.2;
             let isDashed = false;
             const lbl = (e.label || '').toLowerCase();
             const edgeId = e.id ?? `e_${idx}`;
             
             // Расширена логика распознавания паттернов
             if (lbl.includes('выруч') || lbl.includes('финанс') || lbl.includes('обнал') || lbl.includes('налич') || lbl.includes('счет') || lbl.includes('транзакц') || lbl.includes('вывод') || lbl.includes('плательщик')) { edgeColor = '#10b981'; width = 2.5; }
             else if (lbl.includes('заем') || lbl.includes('долг') || lbl.includes('цесс') || lbl.includes('баз') || lbl.includes('расчет') || lbl.includes('уступка')) { edgeColor = '#f59e0b'; width = 2; }
             else if (lbl.includes('суд') || lbl.includes('иск') || lbl.includes('взыскан') || lbl.includes('кредитор') || lbl.includes('проверка') || lbl.includes('юрист') || lbl.includes('судья')) { edgeColor = '#ef4444'; width = 2; }
             
             if (lbl.includes('номи') || lbl.includes('фикт') || lbl.includes('прошлом')) { isDashed = true; }
+            if (hierarchyMeta.cycleEdgeIds.has(edgeId)) { isDashed = true; }
 
             return {
                 ...e,
                 id: edgeId,
                 label: undefined,
                 title: e.title || e.label,
                 width: width,
+                smooth: { enabled: true, type: 'cubicBezier', forceDirection: 'vertical', roundness: 0.16 },
                 color: { color: edgeColor, highlight: '#fff', hover: '#fff' },
                 dashes: isDashed
             };
         });
 
-        const nodes = new vis.DataSet(rawNodesData);
+        const weightedNodes = rawNodesData.map(n => ({
+            ...n,
+            level: hierarchyMeta.levelById.get(n.id),
+            value: hierarchyMeta.nodeWeight.get(n.id) || 1,
+            sortWeight: hierarchyMeta.nodeWeight.get(n.id) || 0,
+            baseLabel: n.label,
+            hiddenByCollapse: false,
+            isCollapsed: false,
+        }));
+
+        const nodes = new vis.DataSet(weightedNodes);
         const edges = new vis.DataSet(processedEdges);
 
         // Fast adjacency index (sidebar/search) — avoids O(E) scans on each click
         const adjacencyEdgeIds = new Map();
         function buildAdjacencyIndex() {
             adjacencyEdgeIds.clear();
             edges.forEach(e => {
                 if (!adjacencyEdgeIds.has(e.from)) adjacencyEdgeIds.set(e.from, []);
                 if (!adjacencyEdgeIds.has(e.to)) adjacencyEdgeIds.set(e.to, []);
                 adjacencyEdgeIds.get(e.from).push(e.id);
                 adjacencyEdgeIds.get(e.to).push(e.id);
             });
         }
         buildAdjacencyIndex();
 
+        const collapsedNodes = new Set();
+
+        function collectDescendants(nodeId, acc = new Set()) {
+            for (const edge of hierarchyMeta.outgoing.get(nodeId) || []) {
+                if (hierarchyMeta.cycleEdgeIds.has(edge.edgeId)) continue;
+                if (acc.has(edge.to)) continue;
+                acc.add(edge.to);
+                collectDescendants(edge.to, acc);
+            }
+            return acc;
+        }
+
+        function updateCollapsedVisibility() {
+            const hiddenIds = new Set();
+            collapsedNodes.forEach(id => {
+                const descendants = collectDescendants(id);
+                descendants.forEach(d => hiddenIds.add(d));
+            });
+
+            const nodeUpdates = nodes.get().map(n => ({
+                id: n.id,
+                hiddenByCollapse: hiddenIds.has(n.id),
+                hidden: hiddenIds.has(n.id)
+            }));
+            nodes.update(nodeUpdates);
+
+            const hiddenById = new Map(nodes.get().map(n => [n.id, !!n.hidden]));
+            edges.update(edges.get().map(e => ({
+                id: e.id,
+                hidden: !!hiddenById.get(e.from) || !!hiddenById.get(e.to)
+            })));
+        }
+
+        function toggleNodeCollapse(nodeId) {
+            if (!hierarchyMeta.outgoing.get(nodeId)?.length) return;
+            if (collapsedNodes.has(nodeId)) collapsedNodes.delete(nodeId);
+            else collapsedNodes.add(nodeId);
+
+            nodes.update([{ id: nodeId, isCollapsed: collapsedNodes.has(nodeId) }]);
+            updateCollapsedVisibility();
+        }
+
+        function applySemanticZoom(scale) {
+            const updates = [];
+            nodes.get().forEach(n => {
+                const full = String(n.baseLabel || n.label || n.id || '').replaceAll('\n', ' ');
+                let nextLabel = '';
+                if (scale > 0.9) nextLabel = full;
+                else if (scale > 0.55) nextLabel = full.slice(0, 24);
+
+                const title = (scale > 1.2 && n.info)
+                    ? `${full}
+${n.info}`
+                    : (n.info || full);
+
+                updates.push({ id: n.id, label: nextLabel, title });
+            });
+            nodes.update(updates);
+        }
+
+        function revealPathToNode(targetId) {
+            if (!hierarchyMeta.rootId || targetId === hierarchyMeta.rootId) return;
+            const queue = [hierarchyMeta.rootId];
+            const parent = new Map([[hierarchyMeta.rootId, null]]);
+
+            while (queue.length && !parent.has(targetId)) {
+                const current = queue.shift();
+                const children = (hierarchyMeta.outgoing.get(current) || [])
+                    .filter(e => !hierarchyMeta.cycleEdgeIds.has(e.edgeId))
+                    .map(e => e.to)
+                    .sort((a, b) => (hierarchyMeta.nodeWeight.get(b) || 0) - (hierarchyMeta.nodeWeight.get(a) || 0));
+
+                for (const child of children) {
+                    if (parent.has(child)) continue;
+                    parent.set(child, current);
+                    queue.push(child);
+                }
+            }
+
+            if (!parent.has(targetId)) return;
+            let cursor = targetId;
+            while (cursor && parent.get(cursor) !== null) {
+                const pId = parent.get(cursor);
+                collapsedNodes.delete(pId);
+                cursor = pId;
+            }
+
+            updateCollapsedVisibility();
+        }
+
 
         const options = {
             nodes: {
                 font: { size: 12, face: 'Inter', color: '#fff', strokeWidth: 4, strokeColor: '#000', multi: 'html' },
                 borderWidth: 2, borderWidthSelected: 4,
                 shadow: { enabled: true, color: 'rgba(0,0,0,0.8)', size: 10, x: 2, y: 2 }
             },
             edges: {
-                smooth: { type: 'continuous', forceDirection: 'none' }, // Возвращаем гибкие линии
+                smooth: { enabled: true, type: 'cubicBezier', forceDirection: 'vertical', roundness: 0.16 },
                 arrows: { to: { enabled: true, scaleFactor: 0.5 } },
                 hoverWidth: 1.5
             },
             groups: {
                 bankrupt: { color: { background: '#dc2626', border: '#991b1b', highlight: { background: '#ef4444', border: '#fff' } }, shape: 'hexagon', size: 30, font: {size: 14, bold: true} },
                 official: { color: { background: '#0284c7', border: '#0369a1', highlight: { background: '#0ea5e9', border: '#fff' } }, shape: 'star', size: 20 },
                 company:  { color: { background: '#10b981', border: '#047857', highlight: { background: '#34d399', border: '#fff' } }, shape: 'square', size: 16 },
                 offshore: { color: { background: '#f59e0b', border: '#b45309', highlight: { background: '#fbbf24', border: '#fff' } }, shape: 'square', size: 16 },
                 hub:      { color: { background: '#8b5cf6', border: '#6d28d9', highlight: { background: '#a78bfa', border: '#fff' } }, shape: 'diamond', size: 22 },
                 person:   { color: { background: '#3b82f6', border: '#1d4ed8', highlight: { background: '#60a5fa', border: '#fff' } }, shape: 'dot', size: 14 },
                 transit:  { color: { background: '#64748b', border: '#334155', highlight: { background: '#94a3b8', border: '#fff' } }, shape: 'dot', size: 8 },
                 // OSINT groups from SpiderFoot
                 osint_ip: { color: { background: '#0891b2', border: '#0e7490', highlight: { background: '#22d3ee', border: '#fff' } }, shape: 'dot', size: 12 },
                 osint_domain: { color: { background: '#0ea5e9', border: '#0284c7', highlight: { background: '#7dd3fc', border: '#fff' } }, shape: 'dot', size: 12 },
                 osint_email: { color: { background: '#14b8a6', border: '#0d9488', highlight: { background: '#5eead4', border: '#fff' } }, shape: 'dot', size: 12 },
                 osint_url: { color: { background: '#10b981', border: '#059669', highlight: { background: '#34d399', border: '#fff' } }, shape: 'dot', size: 12 },
                 osint_asn: { color: { background: '#6366f1', border: '#4f46e5', highlight: { background: '#a5b4fc', border: '#fff' } }, shape: 'dot', size: 12 },
                 osint_misc: { color: { background: '#78716c', border: '#57534e', highlight: { background: '#a8a29e', border: '#fff' } }, shape: 'dot', size: 10 }
             },
+            layout: {
+                hierarchical: {
+                    enabled: true,
+                    direction: 'UD',
+                    sortMethod: 'directed',
+                    nodeSpacing: 160,
+                    levelSeparation: 140,
+                    treeSpacing: 220,
+                    blockShifting: true,
+                    edgeMinimization: true,
+                    parentCentralization: true,
+                    shakeTowards: 'roots'
+                }
+            },
             physics: {
-                solver: 'repulsion',
+                enabled: false,
+                solver: 'hierarchicalRepulsion',
                 repulsion: {
                     nodeDistance: 170,     // Увеличено: дает больше места новым банковским и судебным кластерам
                     centralGravity: 0.05,
                     springLength: 130,     // Увеличено: удлиняет "лучи" от центральных узлов
                     springConstant: 0.05,
                     damping: 0.15
                 },
                 stabilization: { iterations: 400, updateInterval: 50 }
             },
             interaction: { hover: true, tooltipDelay: 200, zoomView: true, dragView: true }
         };
 
         const network = new vis.Network(document.getElementById('network-container'), { nodes, edges }, options);
+        applySemanticZoom(network.getScale());
+
+        network.on('zoom', (params) => {
+            applySemanticZoom(params.scale);
+        });
+
+        network.on('doubleClick', (params) => {
+            if (!params.nodes || params.nodes.length === 0) return;
+            toggleNodeCollapse(params.nodes[0]);
+        });
 
         // ДИНАМИЧЕСКОЕ УПРАВЛЕНИЕ РАДИУСОМ (ДЛИНОЙ ЛУЧЕЙ)
         document.getElementById('springLength').addEventListener('input', function(e) {
             const val = parseInt(e.target.value, 10);
             network.setOptions({
                 physics: {
                     repulsion: {
                         springLength: val
                     }
                 }
             });
             // Пробуждаем физику графа, если она уже стабилизировалась
             network.startSimulation();
         });
 
         // ФИКСАЦИЯ УЗЛА ПРИ ПЕРЕТАСКИВАНИИ (PIN NODE)
         network.on("dragStart", function (params) {
             if (params.nodes.length > 0) {
                 // Временно отключаем фиксацию при захвате, чтобы узел слушался курсора
                 nodes.update(params.nodes.map(id => ({ id: id, fixed: false })));
             }
         });
 
         network.on("dragEnd", function (params) {
             if (params.nodes.length > 0) {
                 // Жестко фиксируем узел (прибиваем гвоздями) там, где его бросили
                 nodes.update(params.nodes.map(id => ({ id: id, fixed: true })));
             }
         });
 
         // ПОИСК УЗЛА
         const MAX_SEARCH_HIGHLIGHT = 200;
         let suggestActiveIndex = -1;
 
         const searchItems = rawNodesData.map(n => {
             const labelPlain = String(n.label || n.id || '').replaceAll('\n', ' ');
             const infoPlain = String(n.info || '');
             return { id: n.id, labelPlain, infoPlain, hay: (labelPlain + ' ' + infoPlain).toLowerCase() };
         });
 
         function chooseNodeById(id) {
             const suggestBox = document.getElementById('search-suggest');
             if (suggestBox) {
                 suggestBox.classList.add('hidden');
                 suggestBox.innerHTML = '';
             }
             suggestActiveIndex = -1;
 
+            revealPathToNode(id);
             network.focus(id, { scale: 1.2, animation: true });
             network.selectNodes([id]);
             showNodeInfo(id);
         }
 
         document.getElementById('node-search').addEventListener('input', (e) => {
             // Upgraded search: suggestions + multi-match highlight (safe & capped)
             const input = e.target;
             const q = (input.value || '').toLowerCase().trim();
             const suggestBox = document.getElementById('search-suggest');
 
             const hideSuggest = () => {
                 suggestBox.classList.add('hidden');
                 suggestBox.innerHTML = '';
                 suggestActiveIndex = -1;
             };
 
             if (q.length < 2) {
                 hideSuggest();
                 if (q.length === 0) resetView();
                 return;
             }
 
             if (typeof clearAnalyticFilter === 'function') {
                 clearAnalyticFilter({ fit: false });
@@ -738,51 +956,51 @@
                 const direction = e.from === id ? '→' : '←';
                 const edgeColor = e.color && e.color.color ? e.color.color : '#666';
                 const otherLabel = String(otherNode.label || otherNode.id || '').replaceAll('\n', ' ');
 
                 return `
                 <div class="p-3 bg-black/40 border border-white/5 rounded-lg mb-2 hover:border-white/20 hover:bg-black/60 cursor-pointer transition-all" onclick="focusOnNode('${otherNode.id}')">
                     <p class="text-[9px] text-zinc-500 uppercase font-bold tracking-widest mb-1 flex items-center gap-2">
                         <span class="w-2 h-0.5 rounded-full" style="background-color: ${edgeColor}"></span> ${direction}
                     </p>
                     <p class="text-xs text-zinc-200 font-medium">${otherLabel}</p>
                 </div>`;
             }).filter(Boolean).join('');
 
             content.innerHTML = `
                 <div class="mb-4">
                     <h3 class="text-[10px] text-zinc-500 uppercase font-black mb-1 tracking-widest">Описание</h3>
                     <p class="text-xs text-zinc-300 leading-relaxed">${node.info || '—'}</p>
                 </div>
                 <h3 class="text-[10px] text-zinc-500 uppercase font-black mb-3 tracking-widest">Связи объекта (${connected.length})</h3>
                 <div class="space-y-1">${links || '<div class="text-xs text-zinc-500">Нет видимых связей</div>'}</div>
             `;
 
             sidebar.classList.remove('hidden');
         }
 
-        function focusOnNode(id) { network.focus(id, { scale: 1.2, animation: true }); network.selectNodes([id]); showNodeInfo(id); }
+        function focusOnNode(id) { revealPathToNode(id); network.focus(id, { scale: 1.2, animation: true }); network.selectNodes([id]); showNodeInfo(id); }
 
         let currentAnalyticFilter = null;
 
         function setAnalyticActive(type) {
             const btns = document.querySelectorAll('[data-analytic-filter]');
             btns.forEach(b => b.classList.remove('active-filter'));
             if (!type) return;
             const btn = document.querySelector(`[data-analytic-filter="${type}"]`);
             if (btn) btn.classList.add('active-filter');
         }
 
         function updateEdgeVisibilityFromNodes() {
             const hiddenById = new Map(nodes.get().map(n => [n.id, !!n.hidden]));
             const updates = edges.get().map(e => ({
                 id: e.id,
                 hidden: !!hiddenById.get(e.from) || !!hiddenById.get(e.to)
             }));
             edges.update(updates);
         }
 
         function showOnlyNodes(visibleIds) {
             const visible = new Set(visibleIds);
             nodes.update(rawNodesData.map(n => ({
                 id: n.id,
                 hidden: !visible.has(n.id)
